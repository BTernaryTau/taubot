import time
import base64
from accounting import Server, Account, AccountId, Authorization
from accounting import parse_account_id
from fractions import Fraction
from typing import Union, Optional, List
from Crypto.PublicKey import ECC
from Crypto.Signature import DSS
from Crypto.Hash import SHA3_512


# EXCEPTIONS
class CommandException(Exception):
    """Commands module superexception, for catching others"""
    pass


class UnauthorizedCommandException(Exception):
    """Thrown on unauthorized command.
    Expect message to be relevant account ids
    """
    pass


class AccountCommandException(Exception):
    """Thrown on problem with account, such as nonexistence.
    Message should be the account id
    """
    pass


class ValueCommandException(Exception):
    """Thrown when a value (such as a transfer amount) is invalid
    in some way, such as account balance being too low. Equivalent to
    4XX errors in HTTP.
    """
    pass


class ProcessCommandException(Exception):
    """Thrown on failure during the process of a executing a command.
    Generic 'process error', equivalent to 5XX errors in HTTP
    """
    pass


# UTILITY FUNCTIONS (mostly module privates)
def _check_authorization(
        subject: Account, object: Account,
        admin_level: Authorization = Authorization.ADMIN,
        min_level: Authorization = Authorization.CITIZEN) -> bool:
    """Check whether subject is authorized to perform operations to object

       Keyword arguments:
       admin_level -- Authorization level to consider "administrative"
       (default Authorization.ADMIN)
       min_level -- Minimum authorization level required (default
       Authorization.ADMIN)
       """
    # Admin-authorization
    if subject.get_authorization().value >= admin_level.value:
        return True

    # Self-authorization
    elif object and subject.get_uuid() == object.get_uuid():
        return subject.get_authorization() >= min_level

    # Proxying?


def _assert_authorized(
        subject: Account, object: Optional[Account],
        admin_level: Authorization = Authorization.ADMIN,
        min_level: Authorization = Authorization.CITIZEN):
    """Raise exception unless subject is authorized to perform
       operations to object

       Keyword arguments:
       admin_level -- Authorization level to consider "administrative"
       (default Authorization.ADMIN)
       min_level -- Minimum authorization level required (default
       Authorization.ADMIN)
       """
    if not _check_authorization(subject, object, admin_level, min_level):
        raise UnauthorizedCommandException(subject, object)


def _get_account(account_id: Union[AccountId, str], server: Server) -> Account:
    """Get account from server, unless it doesn't exist, in which case raise"""
    account_id = parse_account_id(account_id)
    if not server.has_account(account_id):
        raise AccountCommandException(account_id)

    return server.get_account(account_id)


def _is_signed_by(
        account: Union[AccountId, str],
        message: str, signature: str) -> bool:
    """Check whether account has signed message with signature"""
    try:
        signature = base64.b64decode(signature)
    except Exception:
        raise ValueCommandException(signature)

    msg_hash = SHA3_512.new(message.strip().encode('utf-8'))

    for key in account.list_public_keys():
        verifier = DSS.new(key, 'fips-186-3')
        try:
            verifier.verify(msg_hash, signature)
            return True
        except ValueError:
            pass
    return False


# COMMANDS
def transfer(
        author: Union[AccountId, str],  source: Union[AccountId, str],
        destination: Union[AccountId, str],
        amount: Fraction, server: Server):
    """Transfer amount Â¤ from source to destination with authorization
       from author on server"""
    author = _get_account(author, server)
    source = _get_account(source, server)
    destination = _get_account(destination, server)
    _assert_authorized(author, source)

    if not server.can_transfer(source, destination, amount):
        raise ValueCommandException(amount)

    proof = server.transfer(author, source, destination, amount)
    return proof


def open_account(
        author: Union[AccountId, str],
        account: Union[AccountId, str], server: Server):
    """Open account through authorization of author on server.
    Author can be the same account as account"""
    if server.has_account(account):
        raise ValueCommandException(account)
    if server.has_account(author):
<<<<<<< HEAD
        _assert_authorized(_get_account(author, server), None)
    server.open_account(account)
=======
        return 'Hi there %s. Looks like you already have an account. No need to open another one.' % author.readable()

    server.open_account(author)
    return 'Hi there %s. Your account has been opened successfully. Thank you for your business. %s' % (author.readable(), get_generic_help_message(author, prefix, platform_name))

def parse_account_name_command(message: str) -> str:
    """Parses a command that has a single parameter: an account name."""
    body = message.split()
    if len(body) != 2:
        raise CommandException(
            'Incorrectly formatted command; expected `%s ACCOUNT_NAME`.' % body[0])
    return body[1]
>>>>>>> upstream/master


def freeze_account(
        author: Union[AccountId, str],
        account: Union[AccountId, str], server: Server):
    """Freeze account with authorization from author"""
    author = _get_account(author, server)
    account = _get_account(account, server)
    _assert_authorized(author, account, min_level=Authorization.ADMIN)

    server.set_frozen(author, account, True)


def unfreeze_account(
        author: Union[AccountId, str],
        account: Union[AccountId, str], server: Server):
    """Unfreeze account with authorization from author"""
    author = _get_account(author, server)
    account = _get_account(account, server)
    _assert_authorized(author, account, min_level=Authorization.ADMIN)

    server.set_frozen(author, account, False)


<<<<<<< HEAD
def balance(
        author: Union[AccountId, str],
        account: Union[AccountId, str], server: Server) -> Fraction:
    """Get the balance of account with authorization from author"""
    author = _get_account(author, server)
    account = _get_account(account, server)
    _assert_authorized(author, account)
=======
def fraction_to_full_str(frac: Fraction) -> str:
    """Turns a fraction into an easy-to-read string."""
    int_amount = frac.numerator // frac.denominator
    if int_amount <= 0 and frac.numerator != 0:
        return '%d/%d' % (frac.numerator, frac.denominator)
    elif frac.numerator % frac.denominator == 0:
        return str(int_amount)
    else:
        return '%d %d/%d' % (int_amount, frac.numerator - int_amount * frac.denominator, frac.denominator)

def process_full_balance(author: AccountId, message: str, server: Server, **kwargs):
    if not server.has_account(author):
        return 'Hi there %s. I can\'t tell you what the balance on your account is because you don\'t have an account yet. ' \
               'You can open one with the `open` command.' % author.readable()

    account = server.get_account(author)
    main_response = 'The balance on your account is %s.' % fraction_to_full_str(account.get_balance())
    return 'Hi there %s %s. %s Have a great day.' % (
        account.get_authorization().name.lower(), author.readable(), main_response)


def process_balance(author: AccountId, message: str, server: Server, **kwargs):
    """Processes a message requesting the balance on an account."""
    if not server.has_account(author):
        return 'Hi there %s. I can\'t tell you what the balance on your account is because you don\'t have an account yet. ' \
               'You can open one with the `open` command.' % author.readable()
>>>>>>> upstream/master

    return account.get_balance()


def get_money_supply(
        author: Union[AccountId, str],
        server: Server) -> Fraction:
    """Return sum of all account balances"""
    return sum(map(lambda acc: acc.get_balance(),
                   server.get_accounts()))


def add_public_key(
        author: Union[AccountId, str],
        account: Union[AccountId, str],
        key: Union[str, ECC.EccKey], server: Server):
    """Add public key to account, with authorization from author"""
    author = _get_account(author, server)
    account = _get_account(account, server)
    _assert_authorized(author, account)
    if not isinstance(key, ECC.EccKey):
        try:
            key = ECC.import_key(key)
        except:
            raise ValueCommandException(key)
    server.add_public_key(account, key)


def list_accounts(author: Union[AccountId, str], server: Server) -> List[Account]:
    """List all accounts"""
    author = _get_account(author, server)
    _assert_authorized(author, None)
    return server.list_accounts()


def print_money(
        author: Union[AccountId, str],
        account: Union[AccountId, str],
        amount: Fraction, server: Server):
    """Print an amount of money into an account,
       with the authorization of author, on server
       """
    if amount <= 0:
        raise ValueCommandException(amount)

    author = _get_account(author, server)
    account = _get_account(account, server)
    _assert_authorized(author, None)

<<<<<<< HEAD
    server.print_money(author, account, amount)
=======
    if account.get_authorization().value < auth_level.value:
        raise CommandException(
            'Sorry, I can\'t process your request because %s does not have the required authorization.' % account_name.readable())
>>>>>>> upstream/master


def remove_funds(
        author: Union[AccountId, str],
        account: Union[AccountId, str],
        amount: Fraction, server: Server):
    """Remove funds from an account. Rules applying to
       print_money apply.
       """
    if amount <= 0:
        raise ValueCommandException(amount)

<<<<<<< HEAD
    author = _get_account(author, server)
    account = _get_account(account, server)
=======
def parse_authorization(message):
    """Parses an authorization message."""
    body = message.split()
    if len(body) != 3:
        return None

    _, beneficiary, auth_level = body
    auth_level = auth_level.upper()
    try:
        return (beneficiary, Authorization[auth_level])
    except KeyError:
        return None


def process_authorization(author: AccountId, message: str, server: Server, **kwargs):
    """Processes a message requesting an authorization change."""
    author_account = assert_authorized(author, server, Authorization.ADMIN)
    parsed = parse_authorization(message)
    if parsed is None:
        raise CommandException(
            'Authorization formatted incorrectly. The right format is `authorize BENEFICIARY citizen|admin|developer`.')

    beneficiary, auth_level = parsed
    beneficiary_account = assert_is_account(beneficiary, server)
    if beneficiary_account.get_authorization().value > author_account.get_authorization().value:
        raise CommandException(
            'Cannot change authorization of account with authorization %s because it is higher than yours (%s).' % (
                beneficiary_account.get_authorization(),
                author_account.get_authorization()))

    if auth_level.value > author_account.get_authorization().value:
        raise CommandException(
            'Cannot set authorization of account to %s because it is higher than yours (%s).' % (
                auth_level,
                author_account.get_authorization()))

    server.authorize(author, beneficiary_account, auth_level)
    return '%s now has authorization level %s.' % (beneficiary, auth_level.name)


def fraction_to_str(frac: Fraction) -> str:
    """Turns a fraction into an easy-to-read string."""
    int_amount = frac.numerator / frac.denominator
    return str(round(int_amount, 2))


def process_list_accounts(author: AccountId, message: str, server: Server, **kwargs):
    """Processes a message requesting a list of all accounts."""
    return '\n'.join(['| Account | Balance |', '| --- | --- |'] + [
        '| %s%s | %s |' % (
            '' if account.get_authorization() == Authorization.CITIZEN else '**%s** ' % account.get_authorization().name.lower(),
            ' aka '.join(str(x) for x in server.get_account_ids(account)),
            fraction_to_str(account.get_balance()))
        for account in server.list_accounts()
    ])


def parse_print_money(message):
    """Parses a money printing request."""
    body = message.split()
    if len(body) != 3:
        return None

    _, amount_text, beneficiary = body
    try:
        amount = Fraction(amount_text)
    except ValueError:
        return None

    return (amount, parse_account_id(beneficiary))
>>>>>>> upstream/master

    server.remove_funds(author, account, amount)


def create_recurring_transfer(
        author: Union[AccountId, str],
        sender: Union[AccountId, str],
        destinarion: Union[AccountId, str],
        amount: Fraction, tick_count: int, server: Server):
    """Create a recurring transfer."""
    author = _get_account(author, server)
    sender = _get_account(sender, server)
    destination = _get_account(destinarion, server)
    _assert_authorized(author, sender)

    transfer = server.create_recurring_transfer(
<<<<<<< HEAD
            author,
            sender,
            destination,
            amount*tick_count,
            tick_count)

    return transfer


def verify_proxy(
        author: Union[AccountId, str],
        account: Union[AccountId, str],
        signature: str,
        command: str,
        server: Server) -> bool:
    """Verifies a proxy signature of a message."""
    author = _get_account(author, server)
    account = _get_account(account, server)

    if not signature:
        return author in account.get_proxies()
=======
        author,
        author_account,
        dest_account,
        amount * tick_count,
        tick_count)
    return 'Recurring transfer set up with ID `%s`.' % transfer.get_id()


def parse_proxy_command(message):
    """Parses a proxy command into its components."""

    def parse_impl():
        split_message = message.split('\n', 1)
        if len(split_message) != 2:
            return None

        proxy_line, command = split_message
        command = command.strip('\n\r')

        proxy_elems = proxy_line.split()
        if len(proxy_elems) == 2:
            _, account_name = proxy_elems
            return (parse_account_id(account_name), None, command)

        elif len(proxy_elems) == 4:
            _, protocol, account_name, enc_signature = proxy_elems
            if protocol != 'dsa':
                return None

            return (parse_account_id(account_name), enc_signature, command)
        else:
            return None

    result = parse_impl()
    if result == None:
        raise CommandException(
            'Invalid formatting; expected either `proxy PROXIED_ACCOUNT` or `proxy dsa PROXIED_ACCOUNT SIGNATURE` followed by another command on the next line.')
    else:
        return result


def sign_message(message: str, key) -> str:
    """Signs a message's SHA3-512 digest using the DSA algorithm."""
    message = message.strip()
    message_hash = SHA3_512.new(message.encode('utf-8'))
    signer = DSS.new(key, 'fips-186-3')
    return base64.b64encode(signer.sign(message_hash)).decode('utf-8')


def compose_proxy_command(proxied_account_name, key, command):
    """Composes a proxy command."""
    command = command.strip()
    return 'proxy dsa %s %s\n%s' % (proxied_account_name, sign_message(command, key), command)


def is_signed_by(account: Account, message: str, base64_signature: str) -> bool:
    """Checks if `message` with signature `base64_signature` was signed by `account`."""
    try:
        signature = base64.b64decode(base64_signature)
    except Exception as e:
        raise CommandException('Invalid signature. %s' % str(e))

    message_hash = SHA3_512.new(message.strip().encode('utf-8'))
    any_verified = False
    for key in account.list_public_keys():
        verifier = DSS.new(key, 'fips-186-3')
        try:
            verifier.verify(message_hash, signature)
            any_verified = True
        except ValueError:
            pass

        if any_verified:
            break

    return any_verified


def process_proxy_command(author: AccountId, message: str, server: Server, **kwargs):
    """Processes a command by proxy."""
    account_id, signature, command = parse_proxy_command(message)
    account = assert_is_account(account_id, server)

    if signature is None:
        author_account = assert_is_account(author, server)
        if author_account in account.get_proxies():
            return process_command(ProxyAccountId(author, account_id), command, server)
        else:
            raise CommandException('Cannot execute command by proxy because %s is not an authorized proxy for %s.' % (
                author.readable(), account_id.readable()))

    elif is_signed_by(account, command, signature):
        return process_command(ProxyAccountId(author, account_id), command, server)

>>>>>>> upstream/master
    else:
        return _is_signed_by(account, command, signature)


def request_alias(
        author: Union[AccountId, str],
        account: Union[AccountId, str],
        server: Server) -> str:
    """Generates an alias code for linking accounts together"""
    if server.has_account(account):
        raise AccountCommandException(account)
    author = _get_account(author, server)

    key = ECC.generate(curve='P-256')
    signer = DSS.new(key, 'fips-186-3')
    signature = base64.b64encode(signer.sign(
        SHA3_512.new(str(account).encode('utf-8')).decode('utf-8')))
    server.add_public_key(author, key.public_key())

    return signature


def add_alias(
        author: Union[AccountId, str],
        account: Union[AccountId, str],
        signature: str, server: Server):
    """Alias author to account using an alias code (signature)"""
    if server.has_account(author):
        raise AccountCommandException(account)

    account = _get_account(account, server)

    if _is_signed_by(account, str(author), signature):
        server.add_account_alias(account, author)
    else:
<<<<<<< HEAD
        raise ValueCommandException(signature)


def add_proxy(
        author: Union[AccountId, str],
        account: Union[AccountId, str],
        proxy: Union[AccountId, str],
        server: Server):
    """Add proxy to account with authorization from author on server"""
    author = _get_account(author, server)
    account = _get_account(account, server)
    proxy = _get_account(proxy, server)
    _assert_authorized(author, None)

    server.add_proxy(author, proxy, account)


def remove_proxy(
        author: Union[AccountId, str],
        account: Union[AccountId, str],
        proxy: Union[AccountId, str],
        server: Server):
    """Remove proxy 'proxy' from account with authorization from author."""
    author = _get_account(author, server)
    account = _get_account(account, server)
    proxy = _get_account(proxy, server)
    _assert_authorized(author, None)

    server.remove_proxy(author, proxy, account)


def delete_account(
        author: Union[AccountId, str],
        account: Union[AccountId, str], server: Server):
    """Delete account with authorization from account on server."""
    author = _get_account(author)
    _assert_authorized(author, None)

    if not server.delete_account(author, account):
        raise ProcessCommandException()


def add_tax_bracket(
        author: Union[AccountId, str],
        start: Fraction, end: Fraction,
        rate: Fraction, name: str, server: Server):
    """Add a tax bracket to a server with authorization from author"""
    author = _get_account(author, server)
    _assert_authorized(author, None)
    server.add_tax_bracket(author, start, end, rate, name)
=======
        raise CommandException('Cannot set up alias because the signature is invalid.')


def parse_admin_add_proxy_command(message):
    """Parses a transfer command message."""
    body = message.split()
    if len(body) != 3:
        return None

    _, sender, destination = body

    return (sender, destination)


def process_admin_add_proxy(author: AccountId, message: str, server: Server, **kwargs):
    """Processes an admin proxy addition command."""
    assert_authorized(author, server, Authorization.ADMIN)
    parsed = parse_admin_add_proxy_command(message)
    if parsed is None:
        raise CommandException(
            'Incorrect formatting. Expected format `admin-add-proxy ACCOUNT_NAME PROXIED_ACCOUNT_NAME`.')

    account_name, proxied_account_name = parsed
    account = assert_is_account(account_name, server)
    proxied_account = assert_is_account(proxied_account_name, server)
    server.add_proxy(author, account, proxied_account)
    return 'Account %s can now act as a proxy for account %s.' % (account_name, proxied_account_name)


def process_admin_remove_proxy(author: AccountId, message: str, server: Server, **kwargs):
    """Processes an admin proxy addition command."""
    assert_authorized(author, server, Authorization.ADMIN)
    parsed = parse_admin_add_proxy_command(message)
    if parsed is None:
        raise CommandException(
            'Incorrect formatting. Expected format `admin-remove-proxy ACCOUNT_NAME PROXIED_ACCOUNT_NAME`.')

    account_name, proxied_account_name = parsed
    account = assert_is_account(account_name, server)
    proxied_account = assert_is_account(proxied_account_name, server)
    server.remove_proxy(author, account, proxied_account)
    return 'Account %s can no longer act as a proxy for account %s.' % (account_name, proxied_account_name)


def parse_admin_list_proxies(message: str):
    body = message.split()
    if len(body) != 2:
        return None
    _, account = body

    return account


def proccess_admin_list_proxies(author: AccountId, message: str, server: Server, **kwargs):
    """ Lists all of the accounts that can act as the given account."""
    assert_authorized(author, server, Authorization.ADMIN)
    parsed = parse_admin_list_proxies(message)
    if parsed is None:
        raise CommandException('Bad Formating smh')
    account = assert_is_account(parsed, server)
    response = '| -------------------------- |\n'
    for proxy in account.get_proxies():
        response += f'| {str(server.get_account_id(proxy))} |\n'
    response += '| -------------------------- |\n'
    return response


def parse_delete_account(message):
    body = message.split()
    if len(body) != 2:
        return None
    _, account = body
    return account


def process_delete_account(author: AccountId, message: str, server: Server, **kwargs):
    assert_authorized(author, server, Authorization.ADMIN)
    parsed = parse_delete_account(message)
    if parsed is None:
        raise CommandException('Incorrect formatting; **SMH**')
    account = parsed
    return "Success" if server.delete_account(author, account) else 'dunno Something broke'


def process_command(author: AccountId, message: str, server: Server, prefix=''):
    """Processes an arbitrary command."""
    split_msg = message.split()
    if len(split_msg) == 0:
        return 'Hi %s! You sent me an empty message.' % (author.readable())

    # Expand aliases if necessary.
    while split_msg[0] in ALIASES:
        split_msg[0] = ALIASES[split_msg[0]]

    if split_msg[0] in COMMANDS:
        try:
            cmd = COMMANDS[split_msg[0]]
            if len(cmd) >= 4 and cmd[3].value > Authorization.CITIZEN.value:
                assert_authorized(author, server, cmd[3])

            platform_name = 'Discord' if isinstance(author, DiscordAccountId) else 'Reddit'
            return cmd[2](author, message, server, prefix=prefix, platform_name=platform_name)
        except CommandException as e:
            return str(e)
    else:
        return 'Hi %s! I didn\'t quite understand command your command `%s`.' % (
            author.readable(), split_msg[0])  # Sends the help message.


def list_commands(author: AccountId, server: Server):
    """Creates a list of all commands accepted by this bot."""
    return [
        '`%s` â %s' % (COMMANDS[key][0], COMMANDS[key][1])
        for key in sorted(COMMANDS)
        if len(COMMANDS[key]) < 4 or get_authorization_or_citizen(author, server).value >= COMMANDS[key][3].value
    ]


def get_authorization_or_citizen(author: AccountId, server: Server):
    """Gets an account's authorization if it exists and the default citizen authorization otherwise."""
    return server.get_account(author).get_authorization() \
        if server.has_account(author) \
        else Authorization.CITIZEN


def list_commands_as_markdown(author: AccountId, server: Server):
    """Creates a list of all commands accepted by this bot and formats it as Markdown."""
    return '\n'.join('  * %s' % item for item in list_commands(author, server))


PLATFORMS = {
    'Discord': {
        'reach_how': 'by pinging me at the start of a message'
    },
    'Reddit': {
        'reach_how': 'by sending me a private message (I ignore the subject, only the body matters); only PMs work, chat does not',
        'example_username': 'jedi-turncoat'
    }
}


def get_how_to_reach_message(platform_name):
    """Gets a message that tells the user how to reach the bot."""
    how_to_reach_msg = 'Here on %s you can reach me %s.' % (platform_name, PLATFORMS[platform_name]['reach_how'])
    for key, props in PLATFORMS.items():
        if key != platform_name:
            how_to_reach_msg += ' On %s you can reach me %s.' % (key, props['reach_how'])
    return how_to_reach_msg


def get_generic_help_message(author: AccountId, prefix, platform_name):
    """Gets the generic help message for account holders."""
    interpersonal_relation = choice(
        ['friend', 'BFF', 'homie', 'buddy', 'mortal enemy', 'frenemy', 'next door neighbor'])
    suggested_amount = randint(1, 100)
    suggested_name = PLATFORMS[platform_name]['example_username'] if 'example_username' in PLATFORMS[
        platform_name] else prefix
    return '''How can I help you today?

If you want to check your balance, send me this:

> {0}balance

To transfer, say, {1} tau to your {3} {2} just run the following command:

> {0}transfer {1} {2}

For a complete list of commands, run

> {0}reference

If you need help from an actual person, get in touch with the Department of Integration and they'll help you out.'''.format(
        prefix, suggested_amount, suggested_name, interpersonal_relation)


def process_help(author: AccountId, message: str, server: Server, prefix='', platform_name='Reddit', **kwargs):
    """Gets the help message for the economy bot."""
    if server.has_account(author):
        return '''Howdy partner! It's always a pleasure to meet an account holder. %s %s''' % (
            get_how_to_reach_message(platform_name), get_generic_help_message(author, prefix, platform_name))
    else:
        return '''Hi! You look new. {1} If you don't have an account with me yet, you can open one using this command:

> {0}open

Alternatively, if you already have an account then please don't create a new one here.
Instead, link your existing account to {2} by running the following command from a username that's already associated with the account.

> request-alias {3}

(If you're sending me that over Discord you'll also have to ping me at the start of that command.)'''.format(
            prefix, get_how_to_reach_message(platform_name), author.readable(), str(author))


def process_reference(author: AccountId, message: str, server: Server, **kwargs):
    """Gets the command reference message for the economy bot."""
    return '''
Hi %s! Here's a list of the commands I understand:

%s''' % (author.readable(), list_commands_as_markdown(author, server))


def parse_add_tax_bracket(message):
    content = message.split()
    if len(content) != 5 and len(content) != 4:
        return None
    if len(content) == 5:
        _, start, end, rate, name = content
    elif len(content) == 4:
        _, start, rate, name = content
        end = None

    try:
        rate = int(rate)
        end = int(end) if end is not None else None
        start = int(start)
    except ValueError as e:
        return None

    if rate > 100 or rate < 0 or start < 0:
        return None

    if end is not None and start > end:
        raise CommandException('the start of the range needs to be **SMALLER** than the end of the range')

    return start, end, rate, name
>>>>>>> upstream/master


def remove_tax_bracket(
        author: Union[AccountId, str],
        name: str, server: Server):
    """Remove tax bracket by name with authorization from author"""
    author = _get_account(author, server)
    _assert_authorized(author, None)
    server.remove_tax_bracket(author, name)


def force_tax(author: Union[AccountId, str], server: Server):
    """Manually trigger taxation"""
    author = _get_account(author, server)
    _assert_authorized(author, None)
    server.force_tax(author)


<<<<<<< HEAD
def auto_tax(author: Union[AccountId, str], server: Server) -> bool:
    """Toggle automatic taxation"""
    author = _get_account(author, server)
    _assert_authorized(author, None)
    return server.toggle_auto_tax(author)


def force_ticks(
        author: Union[AccountId, str],
        amount: int, server: Server):
    """Forcibly run multiple ticks"""
    author = _get_account(author, server)
    _assert_authorized(author, None)
    for i in range(amount):
        server.notify_tick_elapsed(time.time())
=======
def parse_test_tax_income(message: str):
    content = message.split()
    if len(content) > 2:
        raise CommandException('learn to format smh')
    if len(content) == 1:
        return None

    _, bracket = content
    return bracket


def process_test_tax_income(author: AccountId, message: str, server: Server, **kwargs):
    assert_authorized(author, server, Authorization.ADMIN)
    bracket = parse_test_tax_income(message)
    try:
        value = server.get_bracket_value(bracket)
    except KeyError as e:
        return f"`{bracket}` does not exist smh"
    return f'the value of {bracket if bracket is not None else "all the tax brackets combined"} is {value}, I hope you are not considering tax cus that would be theft'


def parse_force_tick(message):
    content = message.split()
    if len(content) != 2:
        return None
    _, amount = content
    try:
        amount = int(amount)
    except ValueError as e:
        return None

    if amount < 0:
        return None

    return amount





def process_force_tick(author: AccountId, message: str, server: Server, **kwargs):
    assert_authorized(author, server, Authorization.DEVELOPER)
    parsed = parse_force_tick(message)
    if parsed is None:
        raise CommandException("Learn to Format SMH")

    amount = parsed
    i = 0
    while i < amount:
        i += 1
        print(i)
        server.notify_tick_elapsed(time.time())

    return f"successfully forced {amount} ticks"


# A list of command aliases accepted by the bot. Every key
# in this dictionary is recognized as a command and expanded
# to the corresponding value.
ALIASES = {
    'hlp': 'help',
    'ref': 'reference',
    'bal': 'balance',
    'authorise': 'authorize',
    'prxy': 'proxy',
    'fullbal': 'full-balance',
    'full-bal': 'full-balance'
}

# A list of the commands accepted by the bot. Every command
# is essentially a function that maps a message to a reply.
# For convenience, every command is associated with a help
# string here. It's formatted as such:
# 'commandName': ('commandFormat', 'helpDescription', command, Auth Level)
COMMANDS = {
    'reference': (
        'reference',
        'prints a command reference message.',
        process_reference
    ),
    'full-balance': (
        'full-balance',
        'displays your full balance',
        process_full_balance
    ),

    'help': (
        'help',
        'prints a help message.',
        process_help
    ),
    'transfer': (
        'transfer AMOUNT BENEFICIARY',
        'transfers `AMOUNT` to user `BENEFICIARY`\'s account.',
        process_transfer
    ),
    'open': (
        'open',
        'opens a new account.',
        process_open_account
    ),
    'balance': (
        'balance',
        'prints the balance on your account.',
        process_balance
    ),
    'money-supply': (
        'money-supply',
        'tallies the total money supply.',
        process_money_supply
    ),
    'add-public-key': (
        'add-public-key',
        'associates an ECC public key with your account. '
        'The public key should be encoded as the contents of a PEM file that is placed on a line after the command itself.',
        process_add_public_key
    ),
    'proxy': (
        'proxy PROXIED_ACCOUNT -OR- proxy dsa PROXIED_ACCOUNT SIGNATURE',
        'makes `PROXIED_ACCOUNT` perform the action described in the remainder of the message (starting on the next line). '
        'If you use the first form, then you need to be authorized as a proxy of `PROXIED_ACCOUNT.` If you use the second form, '
        '`SIGNATURE` must be an ECDSA-signed SHA3-512 hash of the remainder of the message, where the key that signs the '
        'message must have its public key associated with the proxied account. This command allows a user or application to '
        'safely perform actions on an account holder\'s behalf.',
        process_proxy_command
    ),
    'request-alias': (
        'request-alias ALIAS_ACCOUNT_NAME',
        'generates a code that will allow you to securely associate an alias `ALIAS_ACCOUNT_NAME` with this account. '
        'Concretely, an alias is an additional Reddit or Discord user that you can use to directly '
        'manage this account. If you don\'t know what to put in `ALIAS_ACCOUNT_NAME`, use the name produced by the `name` command.',
        process_request_alias
    ),
    'add-alias': (
        'add-alias ALIASED_ACCOUNT ALIAS_REQUEST_CODE',
        'registers this account as an alias for `ALIASED_ACCOUNT`. `ALIAS_REQUEST_CODE` must be a code '
        'generated by `ALIASED_ACCOUNT` using the `request-alias` command. **NOTE:** for this to work, '
        'the Reddit/Discord account that sends this message **must not** be associated with an existing '
        'account yet.',
        process_add_alias
    ),
    'name': (
        'name',
        'responds with your account name, even if you don\'t have an account yet.',
        process_name
    ),
    'authorize': (
        'authorize ACCOUNT citizen|admin|developer',
        'sets an account\'s authorization.',
        process_authorization,
        Authorization.ADMIN
    ),
    'admin-transfer': (
        'admin-transfer AMOUNT SENDER BENEFICIARY',
        'transfers `AMOUNT` from `SENDER` to `BENEFICIARY`.',
        process_admin_transfer,
        Authorization.ADMIN
    ),
    'list': (
        'list',
        'lists all accounts and the balance on the accounts.',
        process_list_accounts,
        Authorization.ADMIN
    ),
    'print-money': (
        'print-money AMOUNT BENEFICIARY',
        'generates `AMOUNT` money and deposits it in `BENEFICIARY`\'s account.',
        process_print_money,
        Authorization.ADMIN
    ),
    'create-recurring-transfer': (
        'create-recurring-transfer AMOUNT_PER_TICK BENEFICIARY TICK_COUNT',
        'creates a transfer that will transfer `AMOUNT_PER_TICK` from your account to `BENEFICIARY` every tick, for `TICK_COUNT` ticks.',
        process_create_recurring_transfer,
        Authorization.CITIZEN
    ),
    'admin-create-recurring-transfer': (
        'admin-create-recurring-transfer AMOUNT_PER_TICK SENDER BENEFICIARY TICK_COUNT',
        'creates a transfer that will transfer `AMOUNT_PER_TICK` from `SENDER` to `BENEFICIARY` every tick, for `TICK_COUNT` ticks.',
        process_admin_create_recurring_transfer,
        Authorization.ADMIN
    ),
    'admin-open': (
        'admin-open ACCOUNT_NAME',
        'opens a new account with name `ACCOUNT_NAME`. '
        'If an existing user has `ACCOUNT_NAME`, then the newly created account will become that user\'s account.',
        process_admin_open_account,
        Authorization.ADMIN
    ),
    'admin-freeze': (
        'admin-freeze ACCOUNT_NAME',
        'freezes the account with name `ACCOUNT_NAME`.',
        process_admin_freeze,
        Authorization.ADMIN
    ),
    'admin-unfreeze': (
        'admin-unfreeze ACCOUNT_NAME',
        'unfreezes the account with name `ACCOUNT_NAME`.',
        process_admin_unfreeze,
        Authorization.ADMIN
    ),
    'admin-add-proxy': (
        'admin-add-proxy ACCOUNT_NAME PROXIED_ACCOUNT_NAME',
        'gives the account with name `ACCOUNT_NAME` proxy access to the account with name `PROXIED_ACCOUNT_NAME`.',
        process_admin_add_proxy,
        Authorization.ADMIN
    ),
    'admin-remove-proxy': (
        'admin-remove-proxy ACCOUNT_NAME PROXIED_ACCOUNT_NAME',
        'removes the account with name `ACCOUNT_NAME`\'s proxy access to the account with name `PROXIED_ACCOUNT_NAME`.',
        process_admin_remove_proxy,
        Authorization.ADMIN
    ),
    'remove-funds': (
        'remove-funds AMOUNT ACCOUNT',
        'removes `AMOUNT` from `ACCOUNT`',
        process_remove_funds,
        Authorization.ADMIN
    ),
    'delete-account': (
        'delete-account ACCOUNT',
        'deletes `ACCOUNT` and removes all the funds in it',
        process_delete_account,
        Authorization.ADMIN
    ),
    'add-tax-bracket': (
        'add-tax-bracket START END RATE NAME',
        'creates a taxbracket object with the parameters given',
        process_add_tax_bracket,
        Authorization.ADMIN
    ),
    'remove-tax-bracket': (
        'remove-tax-bracket NAME',
        'removes the tax-bracket called `NAME`',
        process_remove_tax_bracket,
        Authorization.ADMIN
    ),
    'force-tax': (
        'force-tax',
        'forces taxes to be collected and resets the current tax tick',
        process_force_tax,
        Authorization.ADMIN
    ), 'toggle-auto-tax': (
        'toggle-auto-tax',
        'turns on automatic taxation',
        process_auto_tax,
        Authorization.ADMIN
    ),
    'force-ticks': (
        # for development purposes only
        # can't think of a reason why anyone other then a dev would need to run it
        # but I needed it so I could test auto tax so added it as a dev command
        'force-ticks AMOUNT',
        'forces AMOUNT of ticks to happen',
        process_force_tick,
        Authorization.DEVELOPER
    ),
    'list-proxies': (
        'list-proxies ACCOUNT',
        'lists all of the accounts that can act on behalf of ACCOUNT',
        proccess_admin_list_proxies,
        Authorization.ADMIN
    ),
    'test-tax-income': (
        'test-tax-income <Tax Bracket>',
        'gets the amount of money earned if `Tax Bracket` is not supplied it will show the sum of all tax brackets',
        process_test_tax_income,
        Authorization.ADMIN
    )

}
>>>>>>> upstream/master
